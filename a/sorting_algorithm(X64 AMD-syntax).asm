.section .data
    arr:
        .byte 5, 2, 4, 6, 1, 3
    n = . - arr

.section .text
.global _start

_start:
    # Алгоритм сортировки пузырьком
    movq $n, %rcx        # rcx - счетчик внешнего цикла (n - 1)
outer_loop:
    movq $0, %rbx        # rbx - флаг сортировки (0 - отсортировано)
    movq %rcx, %rdx      # rdx - индекс верхней границы текущего прохода
    decq %rdx            # уменьшаем на 1, т.к. сравниваем с предыдущим элементом

inner_loop:
    leaq arr(%rip), %rsi      # rsi - адрес начала массива
    movq $1, %rdi             # rdi - индекс текущего элемента
    movq %rdx, %rax           # rax - верхняя граница текущего прохода
    decq %rax                 # уменьшаем на 1, т.к. сравниваем с предыдущим элементом

    cmpq %rdi, %rax           # если индекс текущего элемента больше верхней границы, выходим из цикла
    jg end_inner_loop

    movb (%rsi,%rdi), %al     # загрузка текущего элемента в al
    movb -1(%rsi,%rdi), %dl   # загрузка предыдущего элемента в dl
    cmpb %al, %dl             # сравнение текущего и предыдущего элементов
    jge no_swap               # если текущий >= предыдущего, пропускаем обмен

    # обмен элементов в массиве
    movb %dl, (%rsi,%rdi)
    movb %al, -1(%rsi,%rdi)
    movq $1, %rbx             # устанавливаем флаг сортировки в 1 (не отсортировано)
    
no_swap:
    incq %rdi                 # увеличиваем индекс текущего элемента
    jmp inner_loop            # повторяем внутренний цикл

end_inner_loop:
    testq %rbx, %rbx          # проверяем флаг сортировки
    jnz outer_loop            # если не отсортировано, повторяем внешний цикл

    # завершение программы
    movq $60, %rax            # системный вызов для выхода
    xorq %rdi, %rdi           # код возврата 0
    syscall                   # вызов системного вызова для завершения программы
