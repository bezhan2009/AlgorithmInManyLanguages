; Предполагаем, что массив находится в банке памяти
; Адрес начала массива: $C000

; Регистры: A (аккумулятор), HL (указатель), B (счетчик цикла), C (временный регистр)
; Используем регистры BC для итераций и DE для временного хранения ключа

; Переменные
ARRAY_ADDR  equ $C000       ; Адрес начала массива
ARRAY_LEN   equ 6           ; Длина массива

; Код сортировки вставками
insertion_sort:
    ld  B, ARRAY_LEN        ; Загружаем счетчик цикла (длина массива)
    dec B                   ; Уменьшаем на 1 (последний элемент не требует сортировки)
outer_loop:
    ld  HL, ARRAY_ADDR      ; Загружаем указатель на начало массива
    add HL, B               ; Добавляем текущую итерацию для получения текущего индекса
    ld  A, (HL)             ; Загружаем ключ из текущего индекса
    ld  DE, HL              ; Загружаем DE с текущим индексом

inner_loop:
    dec DE                  ; Уменьшаем DE для сравнения с предыдущими элементами
    ld  C, (DE)             ; Загружаем значение предыдущего элемента в C
    cp  C                   ; Сравниваем ключ с предыдущим элементом
    jp  nc, end_inner_loop  ; Если ключ >= предыдущего элемента, завершаем внутренний цикл
    ld  (DE+1), C           ; Если ключ < предыдущего элемента, сдвигаем предыдущий элемент вправо
    jp  inner_loop          ; Переходим к следующему предыдущему элементу

end_inner_loop:
    ld  (DE+1), A           ; Вставляем ключ в правильную позицию
    dec B                   ; Уменьшаем счетчик цикла
    jp  nz, outer_loop      ; Если счетчик цикла не равен 0, переходим к следующей итерации
    ret                     ; Завершаем сортировку и возвращаемся

; Инициализация массива (для тестирования)
    org $C000
    db 5, 2, 4, 6, 1, 3     ; Массив чисел для сортировки
